### 第六次周总结
   这里有一个好消息，过了这周终于不用做算法题天天裂开了，也有一个坏消息，一入dp深似海，可能上次总结立下的flag得永远立在那了，等明年再把他拔起来（吧）。
好！这总得写点东西的。

##### 对于动态规划问题，我们得在读懂题目的基础上进行以下条件的分析：
1.问题是否具有最优子结构，即每个状态你求出来的结果都是当前状态下的最优解。
2.是否有后效性：若当前的若干个状态一但确定，则此后过程的延边就之和这若干
个状态的值有关，不用考虑这若干个状态是如何获得的。说人话就是，在确保过程
正确的情况下，拿到一个状态（比如一个数据），你只用考虑利用这个数据如何进
行下一步，至于这个数据是怎么得到的，不用管。
暂时没能找到一道吃透的例题，下次总结补上

######  01背包问题
01背包问题是一个比较经典题目，即给你n件商品，每件商品有一定的价值与体积。需要你在有一个总体积限制的情况下选出价值最高的组合。
遇到这种问题，其实可以使用递归的思想，对每一件商品，你有选与不选两种选择，如果不选，则判断下一件商品，同样有选与不选两种情况。如果选择了，就value（a[i+1]，V+b[i]）+a[i] (a[i]是选择的商品的价值，b[i]是选择商品的体积)。今年第一场蓝桥杯第G题就运用了01背包的思想，类似于一次加背包，然后减背包的过程。这里则引用板哥的解法，他是同时进行加背包和减背包的操作，并不断保存每次产生的数据。

###### 题目 
你有一架天平和 N 个砝码，这 N 个砝码重量依次是 W1,W2,⋅⋅⋅,WN。注意砝码可以放在天平两边。请你计算一共可以称出多少种不同的重量？

###### 思路

对于每一个砝码可以选择放在左边或右边，也可以选择不放
设有一数组 dp[i][j]，代表前 i 个物品中，能否凑出重量为 j 的物品 

###### 实现代码
```c++
#include <iostream>
#include <cmath>

using namespace std;

const int N = 110, M = 200020;
int n, m, res;
int w[N], dp[N][M];

int main (){
cin >> n;
for (int i = 1; i <= n; ++ i) {
    cin >> w[i];
    m += w[i]; // 砝码最多能凑出的质量是m最终的重量
}
dp[0][0] = 1;
for (int i = 1; i <= n; ++ i) {
    for (int j = 0; j <= m; ++ j) {
        // dp[i-1][j]              不使用当前砝码
        // dp[i-1][j+w[i]]         
        // dp[i-1][abs(j - w[i])]  
        /*注意，这里的j是期望值，如果j+w[i]这个重量存在的话，那么这里的a[i][j]则           是上一个j通过-w[i]产生的，就是将砝码放在了不同侧。abs(j - w[i])同理
          例如当前的砝码重量是5，我们想知道dp[4][10]存不存在（即能不能称出重量为           10的物品），则我们就得找dp[3][5]存不存在或dp[3][15]存不存在.那dp[3]           [10]可以就可以是对dp[3][15]进行一个减砝码操作或对dp[3][5]进行一个加           砝码的操作*/
        //如果这三者中有一种能凑出来，那么这个重量就有效
        dp[i][j] = dp[i-1][j] || dp[i-1][j+w[i]] || dp[i-1][abs(j - w[i])];//这里是将第i个砝码不断与上面产生的重量进行加或减
    }
}

for (int i = 1; i <= m; ++ i) {
    if (dp[n][i]) res++;
}

cout << res;
return 0;
```
##### 小收尾
本周主要还是在写两个大作业，消耗了不少时间，加上安卓来了新的小伙伴，挺开心的，虽然自己比较菜，但也想好好带他们，祝未来顺利~
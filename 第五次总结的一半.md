## 芜湖，断更好久的总结开始了

#### 本周（这几周），都是蓝桥杯+安卓+各种大作业三点一线，这次我们来康康一些蓝桥杯的东西（先写他一题，后面可能不放题，只写思路了，这是我开启蓝桥杯测试的第一题，mark一下）

#### 问题描述　　
* 有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。
　　每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。
  给出所有芯片的测试结果，问哪些芯片是好芯片。
  

输入格式
　　输入数据第一行为一个整数n，表示芯片个数。
　　第二行到第n+1行为nn的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行     第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏。i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。

输出格式
　　按从小到大的顺序输出所有好芯片的编号
样例输入
3
1 0 1
0 1 0
1 0 1

样例输出
1 3

##### 解析：首先，题目中已知好的芯片比坏的芯片多，而且用每个芯片都测试其他的芯片，那么，对于一个芯片来说，当测试结果为好的次数大于测试结果为坏的次数时，他就是好的芯片。
具体代码实现如下：

```c
#include<stdio.h>
int main(){
int n,a[20][20],i,j,b[20]={0},judge=0,count=0;
scanf("%d",&n);
for(i=0;i<n;i++){
	for(j=0;j<n;j++){
		scanf("%d",&a[i][j]);
	}
}
for(i=0;i<n;i++){
	for(j=0;j<n;j++){
	 if(a[j][i]==1){
	 	judge++;
   } 
}
	if(judge>n/2){
     b[count]=i+1;
	 count++;
	 } 
	 judge=0;
}
for(i=0;i<count;i++){
	printf("%d ",b[i]);
}
return 0;
}
```
#### 好！暂时先写这么一题，不是因为懒，而是当我写完这题的时候突然发现我蓝桥杯的VIP过期了？！很多题都看不了了，其实这道题乍一看很简单，但是真的要抓住题目的信息，切到解题的关键（每个芯片被验成好的次数要大于总芯片的一半），这个还是挺难的，还是得多做，后面陆续会写点正在学的动态规划&深度搜索的东西，还有记录一下我的沙雕低级错误以及其他大佬的解题思路。


